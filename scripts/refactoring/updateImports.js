#!/usr/bin/env node

/**
 * Import path updater script
 * 
 * This script updates import paths in files after the batch renaming process.
 * It uses the rename log generated by batchRename.js to determine what paths need to be updated.
 */

const fs = require('fs');
const path = require('path');
const glob = require('glob');

// Configuration
const CONFIG = {
  dryRun: process.argv.includes('--dry-run'),
  verbose: process.argv.includes('--verbose'),
  renameLogFile: 'rename-log.json',
  logFile: 'import-updates-log.json',
  exclude: [
    'node_modules/**',
    '.git/**',
    'dist/**',
    'build/**',
    '.next/**',
    'coverage/**',
    '.serverless/**'
  ],
  fileExtensions: ['.ts', '.tsx', '.js', '.jsx']
};

// Results log
const updateLog = {
  timestamp: new Date().toISOString(),
  updatedFiles: [],
  errors: []
};

/**
 * Main function
 */
async function main() {
  console.log(`Import path updater - ${CONFIG.dryRun ? 'DRY RUN' : 'LIVE MODE'}`);
  
  // Load the rename log
  if (!fs.existsSync(CONFIG.renameLogFile)) {
    console.error(`Rename log file ${CONFIG.renameLogFile} not found`);
    process.exit(1);
  }
  
  const renameLog = JSON.parse(fs.readFileSync(CONFIG.renameLogFile, 'utf8'));
  
  if (!renameLog.changes || renameLog.changes.length === 0) {
    console.log('No renamed files found in the log');
    process.exit(0);
  }
  
  console.log(`Found ${renameLog.changes.length} renamed files to process`);
  
  // Create a map of old paths to new paths
  const pathMap = new Map();
  for (const change of renameLog.changes) {
    // Store both with and without extension
    pathMap.set(change.from, change.to);
    
    // Also store without extension for handling various import styles
    const extFrom = path.extname(change.from);
    const extTo = path.extname(change.to);
    if (extFrom && extTo) {
      const baseFrom = change.from.slice(0, -extFrom.length);
      const baseTo = change.to.slice(0, -extTo.length);
      pathMap.set(baseFrom, baseTo);
    }
  }
  
  // Get all files to process
  const files = glob.sync(`**/*{${CONFIG.fileExtensions.join(',')}}`, { 
    ignore: CONFIG.exclude
  });
  
  console.log(`Found ${files.length} files to check for imports`);
  
  let updatedCount = 0;
  
  // Process each file
  for (const file of files) {
    try {
      let content = fs.readFileSync(file, 'utf8');
      let updated = false;
      
      // Regular expression to match import/require statements
      const importRegex = /(?:import|require)\s*\(?[\s\S]*?['"]([^'"]*)['"]\)?/g;
      
      // Create a set of updated imports to avoid duplicates
      const updatedImports = new Set();
      
      // Replace all imports
      let match;
      while ((match = importRegex.exec(content)) !== null) {
        const importPath = match[1];
        
        // Skip node_module imports and absolute imports
        if (importPath.startsWith('@') || 
            !importPath.startsWith('.') || 
            importPath.includes('node_modules')) {
          continue;
        }
        
        // Check if this path needs to be updated
        for (const [oldPath, newPath] of pathMap.entries()) {
          // Normalize paths for comparison
          const normalizedOldPath = oldPath.replace(/\\/g, '/');
          const normalizedNewPath = newPath.replace(/\\/g, '/');
          
          // Check if the import path contains the old path
          if (importPath.includes(normalizedOldPath)) {
            const newImportPath = importPath.replace(normalizedOldPath, normalizedNewPath);
            
            if (newImportPath !== importPath) {
              const originalMatch = match[0];
              const newImport = originalMatch.replace(importPath, newImportPath);
              
              // Add to the set of updated imports
              updatedImports.add({ 
                from: importPath, 
                to: newImportPath,
                originalText: originalMatch,
                newText: newImport
              });
              
              updated = true;
            }
          }
        }
      }
      
      // Apply all the updates to the content
      if (updated) {
        let newContent = content;
        
        for (const update of updatedImports) {
          // Replace the import statement
          newContent = newContent.replace(update.originalText, update.newText);
          
          if (CONFIG.verbose) {
            console.log(`${file}: ${update.from} -> ${update.to}`);
          }
        }
        
        if (!CONFIG.dryRun) {
          fs.writeFileSync(file, newContent, 'utf8');
        }
        
        updatedCount++;
        updateLog.updatedFiles.push({
          file,
          updates: Array.from(updatedImports).map(u => ({ from: u.from, to: u.to }))
        });
      }
    } catch (error) {
      console.error(`Error processing ${file}:`, error.message);
      updateLog.errors.push({
        file,
        error: error.message
      });
    }
  }
  
  console.log(`${updatedCount} files were updated with new import paths`);
  
  // Write the log file
  fs.writeFileSync(CONFIG.logFile, JSON.stringify(updateLog, null, 2));
  console.log(`Log written to ${CONFIG.logFile}`);
}

// Run the script
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
}); 