#!/usr/bin/env node

/**
 * Module Refactoring Script
 * 
 * This script helps with refactoring modules by:
 * 1. Creating the appropriate directory structure in the target package
 * 2. Setting up the necessary files (index.ts, types.ts, etc.)
 * 3. Updating package.json exports if needed
 * 4. Creating a migration guide
 * 
 * Usage:
 *   node scripts/refactor-module.js --source <source-path> --target <target-package>/<target-path> [options]
 * 
 * Options:
 *   --source            Source file or directory to refactor
 *   --target            Target location (package/path)
 *   --name              Module name (defaults to last part of source path)
 *   --add-exports       Add exports to package.json
 *   --create-tests      Create test files
 *   --create-docs       Create documentation
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Parse command line arguments
const args = process.argv.slice(2);
const options = {
  source: null,
  target: null,
  name: null,
  addExports: false,
  createTests: false,
  createDocs: false
};

for (let i = 0; i < args.length; i++) {
  if (args[i] === '--source' && args[i+1]) {
    options.source = args[i+1];
    i++;
  } else if (args[i] === '--target' && args[i+1]) {
    options.target = args[i+1];
    i++;
  } else if (args[i] === '--name' && args[i+1]) {
    options.name = args[i+1];
    i++;
  } else if (args[i] === '--add-exports') {
    options.addExports = true;
  } else if (args[i] === '--create-tests') {
    options.createTests = true;
  } else if (args[i] === '--create-docs') {
    options.createDocs = true;
  }
}

// Validate required options
if (!options.source || !options.target) {
  console.error('Error: --source and --target are required');
  process.exit(1);
}

// Set default module name if not provided
if (!options.name) {
  options.name = path.basename(options.source, path.extname(options.source));
}

console.log('ðŸ“¦ Module Refactoring Tool');
console.log('Options:', options);

// Parse target into package and path
const targetParts = options.target.split('/');
const targetPackage = targetParts[0];
const targetPath = targetParts.slice(1).join('/');

// Determine source and target paths
const sourcePath = path.resolve(options.source);
const targetPackagePath = path.resolve('packages', targetPackage);
const targetFullPath = path.resolve(targetPackagePath, 'src', targetPath);

// Check if source exists
if (!fs.existsSync(sourcePath)) {
  console.error(`Error: Source path ${sourcePath} does not exist`);
  process.exit(1);
}

// Check if target package exists
if (!fs.existsSync(targetPackagePath)) {
  console.error(`Error: Target package ${targetPackagePath} does not exist`);
  process.exit(1);
}

// Create target directory if it doesn't exist
if (!fs.existsSync(targetFullPath)) {
  console.log(`Creating target directory: ${targetFullPath}`);
  fs.mkdirSync(targetFullPath, { recursive: true });
}

// Copy source to target
console.log(`Copying from ${sourcePath} to ${targetFullPath}`);

// Determine if source is a file or directory
const sourceStats = fs.statSync(sourcePath);
if (sourceStats.isFile()) {
  // Copy single file
  const targetFile = path.join(targetFullPath, path.basename(sourcePath));
  fs.copyFileSync(sourcePath, targetFile);
  console.log(`Copied ${sourcePath} to ${targetFile}`);
} else if (sourceStats.isDirectory()) {
  // Copy directory contents
  const files = fs.readdirSync(sourcePath);
  for (const file of files) {
    const sourceFile = path.join(sourcePath, file);
    const targetFile = path.join(targetFullPath, file);
    
    if (fs.statSync(sourceFile).isFile()) {
      fs.copyFileSync(sourceFile, targetFile);
      console.log(`Copied ${sourceFile} to ${targetFile}`);
    }
  }
}

// Create index.ts if it doesn't exist
const indexPath = path.join(targetFullPath, 'index.ts');
if (!fs.existsSync(indexPath)) {
  console.log(`Creating index.ts at ${indexPath}`);
  
  // Determine files to export
  const files = fs.readdirSync(targetFullPath);
  const tsFiles = files.filter(file => 
    file.endsWith('.ts') && 
    file !== 'index.ts' && 
    !file.endsWith('.test.ts') && 
    !file.endsWith('.spec.ts')
  );
  
  // Generate exports
  let indexContent = '// Generated by refactor-module.js\n\n';
  
  for (const file of tsFiles) {
    const baseName = path.basename(file, '.ts');
    indexContent += `export * from './${baseName}';\n`;
  }
  
  fs.writeFileSync(indexPath, indexContent);
}

// Create types.ts if it doesn't exist
const typesPath = path.join(targetFullPath, 'types.ts');
if (!fs.existsSync(typesPath)) {
  console.log(`Creating types.ts at ${typesPath}`);
  
  const typesContent = `// Generated by refactor-module.js

/**
 * Types for ${options.name} module
 */

export interface ${options.name.charAt(0).toUpperCase() + options.name.slice(1)}Options {
  // Add options here
}

export interface ${options.name.charAt(0).toUpperCase() + options.name.slice(1)}Result {
  // Add result type here
}
`;
  
  fs.writeFileSync(typesPath, typesContent);
}

// Create tests if requested
if (options.createTests) {
  const testDir = path.join(targetPackagePath, 'tests');
  if (!fs.existsSync(testDir)) {
    fs.mkdirSync(testDir, { recursive: true });
  }
  
  const testPath = path.join(testDir, `${options.name}.test.ts`);
  console.log(`Creating test file at ${testPath}`);
  
  const testContent = `// Generated by refactor-module.js

import { ${options.name} } from '../src/${targetPath}';

describe('${options.name}', () => {
  it('should be defined', () => {
    expect(${options.name}).toBeDefined();
  });
  
  // Add more tests here
});
`;
  
  fs.writeFileSync(testPath, testContent);
}

// Create documentation if requested
if (options.createDocs) {
  const docsDir = path.join(targetPackagePath, 'docs');
  if (!fs.existsSync(docsDir)) {
    fs.mkdirSync(docsDir, { recursive: true });
  }
  
  const docPath = path.join(docsDir, `${options.name.toUpperCase()}_MIGRATION.md`);
  console.log(`Creating documentation at ${docPath}`);
  
  const docContent = `# ${options.name} Migration Guide

## Overview

This document provides guidance for migrating to the new \`${options.name}\` implementation in the \`@mindburn/${targetPackage}\` package.

## Changes

The \`${options.name}\` module has been moved from \`${options.source}\` to \`@mindburn/${targetPackage}/${targetPath}\`.

## Migration Steps

1. Update imports:

\`\`\`typescript
// Before
import { ${options.name} } from '${options.source}';

// After
import { ${options.name} } from '@mindburn/${targetPackage}/${targetPath.replace(/\\/g, '/')}';
\`\`\`

## API Changes

- [List any API changes here]

## Examples

\`\`\`typescript
// Example usage
import { ${options.name} } from '@mindburn/${targetPackage}/${targetPath.replace(/\\/g, '/')}';

// Usage example
\`\`\`

## Additional Notes

- [Add any additional notes here]
`;
  
  fs.writeFileSync(docPath, docContent);
}

// Update package.json exports if requested
if (options.addExports) {
  const packageJsonPath = path.join(targetPackagePath, 'package.json');
  console.log(`Updating exports in ${packageJsonPath}`);
  
  try {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    
    // Initialize exports if it doesn't exist
    if (!packageJson.exports) {
      packageJson.exports = {
        '.': {
          types: './dist/index.d.ts',
          import: './dist/index.js',
          require: './dist/index.js'
        }
      };
    }
    
    // Add new export
    const exportPath = `./${targetPath.replace(/\\/g, '/')}`;
    packageJson.exports[exportPath] = {
      types: `./dist/${targetPath}/index.d.ts`,
      import: `./dist/${targetPath}/index.js`,
      require: `./dist/${targetPath}/index.js`
    };
    
    // Update typesVersions if it exists
    if (packageJson.typesVersions) {
      if (!packageJson.typesVersions['*']) {
        packageJson.typesVersions['*'] = {};
      }
      
      packageJson.typesVersions['*'][targetPath] = [`./dist/${targetPath}/index.d.ts`];
    }
    
    // Write updated package.json
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    console.log(`Updated exports in ${packageJsonPath}`);
  } catch (error) {
    console.error(`Error updating package.json: ${error.message}`);
  }
}

console.log('\nâœ… Module refactoring complete!');
console.log('\nNext steps:');
console.log('1. Review the generated files and make any necessary adjustments');
console.log('2. Update imports in dependent files');
console.log('3. Run tests to ensure functionality is preserved');
console.log('4. Remove the original code once all references are updated');

// Make the script executable
try {
  execSync('chmod +x scripts/refactor-module.js');
} catch (error) {
  // Ignore errors on Windows
} 